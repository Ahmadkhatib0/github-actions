Reorganize the Ansible content into three parts:
  • Core components, created by the Ansible team
  • Certified content, created by Red Hat’s business partners
  • Community content, created by thousands of enthusiasts worldwide


Where Should I Put My ansible.cfg File?
Ansible looks for an ansible.cfg file in the following places, in this order:
  • File specified by the ANSIBLE_CONFIG environment variable
  • ./ansible.cfg (ansible.cfg in the current directory)
  • ~/.ansible.cfg (.ansible.cfg in your home directory)
  • /etc/ansible/ansible.cfg (Linux) or /usr/local/etc/ansible/ansi‐ble.cfg (*BSD)


Ansible uses /etc/ansible/hosts as the default location for the inventory file. 
Keeping the inventory in the same directory as the play‐ books and so on gives you 
the possibility of a specific inventory per project instead of just a global one.

We use the .j2 extension to indicate that the file is a Jinja2 template. However, you can
use a different extension if you like; Ansible doesn’t care.

In ch3/playbooks/templates/nginx.conf.j2 file 
server_name
  The hostname of the web server (such as www.example.com)
cert_file
  The filename of the TLS certificate
key_file
  The filename of the TLS private key
tls_dir
  The directory with the above files



You don’t need to install Ansible on your machine to use it when you have config.vm.provision "ansible_local" 
in your Vagrantfile; it will be installed and run in the virtual machine. When you use 
config.vm.provision "ansible" in the Vagrantfile, the provisioner does use Ansible on your machine.

-- The vagrant-hostmanager plug-in helps in addressing multiple virtual machines by hostname.
-- The vagrant-vbguest plug-in works on VirtualBox and can automatically install or
   update Guest Additions in your guest virtual machines

-- An Ansible convention is to copy files from a subdirectory named files, and to source Jinja2 
   templates from a subdirectory named templates. Ansible searches these directories automatically.

-- End of File:  YAML files may end with three dots, which can be useful to 
   prove completeness. But quite often this practice is skipped.

-- Booleans:  YAML has a native Boolean type and provides you with a variety of values that
   evaluate to true or false. For example, these are all Boolean true values in YAML:
   true, True, TRUE, yes, Yes, YES, on, On, ON
   These are all Boolean false values in YAML:
   false, False, FALSE, no, No, NO, off, Off, OFF

--  YAML also supports an inline format for lists, with comma-separated values in square brackets:
    shows: [ My Fair Lady , Oklahoma , The Pirates of Penzance ]
    
-- YAML also supports an inline format for dictionaries, with comma-separated tuples in braces:
    address: { street: Main Street, appt: '742', city: Logan, state: Ohio}

-- Multiline Strings
    You can format multiline strings with YAML by combining a block style indicator
    (| or >), a block chomping indicator (+ or –), and even an indentation indicator
    (1 to 9). For example, when we need a preformatted block, we use the pipe character with a plus sign (|+),
    So The YAML parser will keep all line breaks as you enter them:
  ---
  visiting_address: |+
    Department of Computer Science
    A.V. Williams Building
    University of Maryland
  city: College Park
  state: Maryland

-- If you reference a variable right after specifying the module, the YAML parser will misinterpret the 
   variable reference as the beginning of an inline dictionary. Consider the following example:
- name: Perform some task
   command: {{ myapp }} -a foo
Ansible will try to parse the first part of {{ myapp }} -a foo as a dictionary instead
of a string, and will return an error. In this case, you must quote the arguments:
- name: Perform some task
    command: "{{ myapp }} -a foo"






become:
  If this Boolean variable is true, Ansible will become the become_user to run tasks. This is useful when 
  managing Linux servers, since by default you should not log in as the root user. become can be specified 
  per task, or per play, as needed, and become_user can be used to specify root (the default if omitted) or
  another user, yet become is subject to your system’s policies. 
  A sudoers file might need to be adjusted to be able to become root.

package
  Installs or removes packages by using the host’s package manager
copy
  Copies a file from the machine where you run Ansible to the web servers
file
  Sets the attribute of a file, symlink, or directory
service
  Starts, stops, or restarts a service
template
  Generates a file from a template and copies it to the hosts

When you want to run a task with each item from a list, you can use loop. A loop executes the task 
  multiple times, each time replacing item with different values from the specified list:
loop:
  - "{{ key_file }}"
  - "{{ cert_file }}"
notify: Restart nginx


Handlers are one of the conditional forms that Ansible supports. A handler is similar to a task, but it 
  runs only if it has been notified by a task. A task will fire the notification if Ansible recognizes 
  that the task has changed the state of the system. If a play contains multiple handlers, the handlers 
  always run in the order that they are defined in the handlers section, not the notification order. 
  They run only once, even if they are notified multiple times. The official Ansible documentation mentions 
  that the only common uses for han‐ dlers are reboots and restarting services. Lorin uses them only for 
  restarting serv‐ ices—he thinks it’s a pretty small optimization to restart only once on change, since
  we can always just unconditionally restart the service at the end of the playbook, and
  restarting a service doesn’t usually take very long. But when you restart NGINX, you
  might affect user sessions; notifying handlers help avoid unnecessary restarts. Bas
  likes to validate the configuration before restarting, especially if it’s a critical service
  like sshd. He has handlers notifying handlers.
  
Testing
One pitfall with handlers is that they can be troublesome when debugging a play‐
book. The problem usually unfolds something like this:
• You run a playbook.
• One of the tasks with a notify on it changes state.
• An error occurs on a subsequent task, stopping Ansible.
• You fix the error in your playbook.
• You run Ansible again.
• None of the tasks reports a state change the second time around, so Ansible doesn’t run the handler.



