Reorganize the Ansible content into three parts:
  • Core components, created by the Ansible team
  • Certified content, created by Red Hat’s business partners
  • Community content, created by thousands of enthusiasts worldwide


Where Should I Put My ansible.cfg File?
Ansible looks for an ansible.cfg file in the following places, in this order:
  • File specified by the ANSIBLE_CONFIG environment variable
  • ./ansible.cfg (ansible.cfg in the current directory)
  • ~/.ansible.cfg (.ansible.cfg in your home directory)
  • /etc/ansible/ansible.cfg (Linux) or /usr/local/etc/ansible/ansi‐ble.cfg (*BSD)


Ansible uses /etc/ansible/hosts as the default location for the inventory file. 
Keeping the inventory in the same directory as the play‐ books and so on gives you 
the possibility of a specific inventory per project instead of just a global one.

We use the .j2 extension to indicate that the file is a Jinja2 template. However, you can
use a different extension if you like; Ansible doesn’t care.

In ch3/playbooks/templates/nginx.conf.j2 file 
server_name
  The hostname of the web server (such as www.example.com)
cert_file
  The filename of the TLS certificate
key_file
  The filename of the TLS private key
tls_dir
  The directory with the above files



You don’t need to install Ansible on your machine to use it when you have config.vm.provision "ansible_local" 
in your Vagrantfile; it will be installed and run in the virtual machine. When you use 
config.vm.provision "ansible" in the Vagrantfile, the provisioner does use Ansible on your machine.

-- The vagrant-hostmanager plug-in helps in addressing multiple virtual machines by hostname.
-- The vagrant-vbguest plug-in works on VirtualBox and can automatically install or
   update Guest Additions in your guest virtual machines

-- An Ansible convention is to copy files from a subdirectory named files, and to source Jinja2 
   templates from a subdirectory named templates. Ansible searches these directories automatically.

-- End of File:  YAML files may end with three dots, which can be useful to 
   prove completeness. But quite often this practice is skipped.

-- Booleans:  YAML has a native Boolean type and provides you with a variety of values that
   evaluate to true or false. For example, these are all Boolean true values in YAML:
   true, True, TRUE, yes, Yes, YES, on, On, ON
   These are all Boolean false values in YAML:
   false, False, FALSE, no, No, NO, off, Off, OFF

--  YAML also supports an inline format for lists, with comma-separated values in square brackets:
    shows: [ My Fair Lady , Oklahoma , The Pirates of Penzance ]
    
-- YAML also supports an inline format for dictionaries, with comma-separated tuples in braces:
    address: { street: Main Street, appt: '742', city: Logan, state: Ohio}

-- Multiline Strings
    You can format multiline strings with YAML by combining a block style indicator
    (| or >), a block chomping indicator (+ or –), and even an indentation indicator
    (1 to 9). For example, when we need a preformatted block, we use the pipe character with a plus sign (|+),
    So The YAML parser will keep all line breaks as you enter them:
  ---
  visiting_address: |+
    Department of Computer Science
    A.V. Williams Building
    University of Maryland
  city: College Park
  state: Maryland

-- If you reference a variable right after specifying the module, the YAML parser will misinterpret the 
   variable reference as the beginning of an inline dictionary. Consider the following example:
- name: Perform some task
   command: {{ myapp }} -a foo
Ansible will try to parse the first part of {{ myapp }} -a foo as a dictionary instead
of a string, and will return an error. In this case, you must quote the arguments:
- name: Perform some task
    command: "{{ myapp }} -a foo"






become:
  If this Boolean variable is true, Ansible will become the become_user to run tasks. This is useful when 
  managing Linux servers, since by default you should not log in as the root user. become can be specified 
  per task, or per play, as needed, and become_user can be used to specify root (the default if omitted) or
  another user, yet become is subject to your system’s policies. 
  A sudoers file might need to be adjusted to be able to become root.

package
  Installs or removes packages by using the host’s package manager
copy
  Copies a file from the machine where you run Ansible to the web servers
file
  Sets the attribute of a file, symlink, or directory
service
  Starts, stops, or restarts a service
template
  Generates a file from a template and copies it to the hosts

When you want to run a task with each item from a list, you can use loop. A loop executes the task 
  multiple times, each time replacing item with different values from the specified list:
loop:
  - "{{ key_file }}"
  - "{{ cert_file }}"
notify: Restart nginx


Handlers are one of the conditional forms that Ansible supports. A handler is similar to a task, but it 
  runs only if it has been notified by a task. A task will fire the notification if Ansible recognizes 
  that the task has changed the state of the system. If a play contains multiple handlers, the handlers 
  always run in the order that they are defined in the handlers section, not the notification order. 
  They run only once, even if they are notified multiple times. The official Ansible documentation mentions 
  that the only common uses for han‐ dlers are reboots and restarting services. Lorin uses them only for 
  restarting serv‐ ices—he thinks it’s a pretty small optimization to restart only once on change, since
  we can always just unconditionally restart the service at the end of the playbook, and
  restarting a service doesn’t usually take very long. But when you restart NGINX, you
  might affect user sessions; notifying handlers help avoid unnecessary restarts. Bas
  likes to validate the configuration before restarting, especially if it’s a critical service
  like sshd. He has handlers notifying handlers.
  
Testing
One pitfall with handlers is that they can be troublesome when debugging a play‐
book. The problem usually unfolds something like this:
• You run a playbook.
• One of the tasks with a notify on it changes state.
• An error occurs on a subsequent task, stopping Ansible.
• You fix the error in your playbook.
• You run Ansible again.
• None of the tasks reports a state change the second time around, so Ansible doesn’t run the handler.



The Ansible inventory is a very flexible object: it can be a file (in several formats), a directory, or an 
  executable, and some executables are bundled as plug-ins. Inventory plug-ins allow us to point at data 
  sources, like your cloud provider, to compile the inventory. An inventory can be stored separately 
  from your playbooks. This means that you can create one inventory directory to use with Ansible on 
  the command line, with hosts running in Vagrant, Amazon EC2, Google Cloud Platform, or Microsoft
  Azure, or wherever you like!

Ansible automatically adds one host to the inventory by default: localhost. It understands that localhost 
refers to your local machine, with which it will interact directly rather than connecting by SSH.

ansible_connection
  Ansible supports multiple transports, which are mechanisms that Ansible uses
  to connect to the host. The default transport, smart, will check whether the
  locally installed SSH client supports a feature called ControlPersist. If the SSH
  client supports ControlPersist, Ansible will use the local SSH client. If not, the
  smart transport will fall back to using a Python-based SSH client library called Paramiko.
  
ansible_shell_type
  Ansible works by making SSH connections to remote machines and then invoking scripts. By default, 
  Ansible assumes that the remote shell is the Bourne shell located at /bin/sh, and will generate 
  the appropriate command-line parameters that work with that. It creates temporary directories to 
  store these scripts. Ansible also accepts csh, fish, and (on Windows) powershell as valid values for
  this parameter. Ansible doesn’t work with restricted shells.
  
ansible_python_interpreter
  Ansible needs to know the location of the Python interpreter on the remote
  machine. You might want to change this to choose a version that works for you.
  The easiest way to run Ansible under Python 3 is to install it with pip3 and set this:
  ansible_python_interpreter="/usr/bin/env python3"
  
ansible_*_interpreter
  If you are using a custom module that is not written in Python, you can use this
  parameter to specify the location of the interpreter (such as /usr/bin/ruby)

Behavioral inventory parameter        ansible.cfg option
ansible_port                          remote_port
ansible_user                          remote_user
ansible_ssh_private_key_file          ssh_private_key_file
ansible_shell_type                    executable (see the following paragraph)

The ansible.cfg executable config option is not exactly the same as the ansi
  ble_shell_type behavioral inventory parameter. The executable specifies the full path of the shell 
  to use on the remote machine (for example, /usr/local/bin/fish). Ansible will look at the base name 
  of this path (in this case fish) and use that as the default value for ansible_shell_type.



Ansible also supports using <hostname>:<port> syntax when specifying hosts, so we
could replace the line that contains vagrant1 with 127.0.0.1:2222
[vagrant]
127.0.0.1:2222
127.0.0.1:2200
127.0.0.1:2201

However, we can’t actually run what you see in above, The reason is that Ansible’s inventory can associate 
only a single host with 127.0.0.1, so the Vagrant group would contain only one host instead of three.

The “cattle” approach to servers is much more scalable, and Ansible supports it well by supporting numeric 
  patterns. For example, if your 20 servers are named web1.example.com, web2.example.com, and so on, 
  then you can specify them in the inventory file like this:
[web]
web[1:20].example.com

If you prefer to have a leading zero (such as web01.example.com), specify that in the range, like this:
[web]
web[01:20].example.com

Ansible also supports using alphabetic characters to specify ranges. If you want to use the convention 
  web-a.example.com, web-b.example.com, and so on, for your 20 servers, then you can do this:
[web]
web-[a:t].example.com

We could define a variable named color and set it to a value for each server:
  amsterdam.example.com color=red
  seoul.example.com color=green
  sydney.example.com color=blue
  toronto.example.com color=purple

For example, if Lorin has a directory containing his playbooks at /home/lorin/playbooks/ with 
  an inventory directory and hosts file at /home/lorin/inventory/hosts, he
  should put variables for the amsterdam.example.com host in the file /home/lorin/
  inventory/host_vars/amsterdam.example.com and variables for the production group
  in the file /home/lorin/inventory/group_vars/production
If we want to break things out even further, Ansible lets us define group_vars/produc‐
  tion as a directory instead of a file. We can place multiple YAML files into it that
  contain variable definitions. For example, we could put database-related variables in
  one file and the RabbitMQ-related variables in another file

If the inventory file is marked executable, Ansible will assume it is a dynamic 
  inventory script and will execute the file instead of reading it.

An Ansible dynamic inventory script must support two command-line flags:
  • --host=<hostname> for showing host details
  • --list for listing groups



